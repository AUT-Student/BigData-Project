# ابتدای فصل
## پاراگراف اول
شمارش تعداد دورهای در یک گراف یک مسئله پایه‌ی در حوزه مدل جریانی گرافی است. شمارش مثلث‌ها به عنوان نوع خاص بیشتر مورد بررسی بوده است و کاربردهای زیادی داشته است. به طور خاص این مورد بینش مهمی از ویژگی‌های ساختاری شبکه‌ها می‌دهد که می‌تواند استفاده شود تا شکل عمده شبکه‌های تعمال پروتئین، فهم شبکه‌های اجتماعی و ارزیابی مدل‌های گرافی بزرگ را کشف کند.

## پاراگراف دوم
به دلیل اهمیت آن بدنه مهمی از تحقیقات به الگوریتم‌های جریانی که از نظر فضایی برای شمارش مثلث با خطای 1+e بهینه است تعلق دارد. چنین الگوریتم‌هایی محاسبه را در یک یا چند گام اول روی داده با استفاده پیچیدگی خطی (sub-linear) از نظر زمانی انجام می‌دهد.  یک مشکل مشترک در تمام کارهای قبلی وجود یال‌های سنگین (heavy edge) بوده است. چنین یال‌هایی در مثلث‌های زیادی وجود دارد. الگوریتم‌ها با پیچیدگی خطی از نظر حافظه غالبا برپایه نمونه‌برداری از یال‌ها هستند که در نتیجه انتخاب و ذخیره‌سازی یک یال سنگین که تاثیر شدیدی بر تعداد مثلث‌ها دارد می‌تواند کلید یک پیش‌بینی دقیق باشد. بنابراین چندین تکنیک توسعه داده‌شده است که تشخیص دهد آیا یک یال سنگین است یا خیر.

## پاراگراف سوم
اخیرا برپایه مشاهد‌ه اینکه تعداد زیادی از الگوهای اساسی در مجموعه‌داده‌های واقعی سه سرعت در طول زمان تغییر نمی‌کند، تکنیک‌های یادگیری‌ماشین در مدل جریان‌داده با آموزش اوراکل‌های ضربه‌زن سنگین (heavy-hitter) ادغام شده است. دسترسی داشتن به چنین اوراکل برپایه یادگیری ماشین رنج وسیعی از مسائل در پردازش جریان داده را بهبود داده است. حد حافظه از الگوریتم‌های کلاسیک پیشین در تمام این روش‌ها بهتر است.


## پاراگراف چهارم
برپایه پیشرفت‌های اخیر به این پرسش رسیده‌اند که آیا امکان پذیر است که یک اوراکل یال سنگین آموزش‌یافته پیچیدگی فضایی شمارش زیر گراف در یک مدل جریانی گرافی را بهبود دهد. نتایج نشان می‌دهد که پاسخ مثبت است!

# بخش ۱.۱ 
## پاراگراف اول
نتایج عملی و تئوری در چندین مدل جریانی گرافی با چندین نمایش از اواکل‌های پیش‌بینی‌کننده ارائه شده است. از نظر مفهومی بهتر است اول اوراکل‌های کامل (Perfect Oracle) مطالعه شوند که پیش‌بینی دقیقی داشته‌اند. در عمل چنین اوراکلی در دسترس نیست. ارزیابی این اوراکل‌ها از دو طریق صورت گرفته است:
* نشان‌دادن آنکه می‌توانند برای چندین مجموعه‌داده واقعی ساخته شوند.
* نشان‌دادن آنکه در مجموعه‌داده‌های واقعی الگوریتم پشینهادی با استفاده از چنین اوراکل‌هایی بهبود عملی قابل توجهی نسبت به مدل‌های پایه داشته است.

## پاراگراف دوم
$G(V, E)$ گراف ورودی است که $n$، $m$ و $T$ به ترتیب تعداد گره، یال و مثلث‌ها در $G$ باشد. دو نوع مدل جریانی یالی گرافی اصلی وجود دارد: مدل مجاورت لیستی (Adjacency List) و مدل ترتیب دلخواه (Arbitrary Order).
نشان داده‌اند که آموزش اوراکل‌های یال سنگین در عمل با هر دو مدل ممکن است و چنین اوراکلی امکان طراحی الگوریتم‌های جدید که بهبود قابل ملاحظه‌ای بر پیچیدگی فضایی شمارش مثلث‌ها و چهارتایی بگذارد را ممکن می‌کند؛ چه به صورت تئوری و چه در عمل. به علاوه رسمی‌کردن چهارچوب پیش‌بینی یال سنگین نشان دادن حدپایین قابل اثبات را امکان‌پذیر می‌کند. نتایج در جدول ۱ آورده شده است. ( در جدول ۱ $\Delta_E$ و $\Delta_V$ بیشینه تعداد مثلث برای یال و هر گره را نشان می‌دهد و $\kappa$ مقدار arboricity گراف را نشان می‌دهد.)
![[Pasted image 20220709124947.png]]

## پاراگراف سوم
در الگوریتم پیشنهادی فرض شده است که تقریب ثابت بزرگ (large-constant approximation) از $T$ برای هدف تنظیم پارامترهای مختلف شناخته شده است. این یک کار استاندارد در حوزه شمارش جریانی زیرگراف‌ها است. به علاوه زمانی که این فرض مستقیما قابل استنتاج نباشد بخش F.3 مقاله در مورد نحوه تطبیق روش پیشنهادی برای غلبه به این مشکل ارائه شده است.


# اوراکل کامل
## پاراگراف اول
اولین نتایج در حالتی که الگوریتم‌ها دسترسی به اوراکل یال سنگین کامل داردند بدست آمرده است. برای حدآستانه $\rho$ یک اوراکل به طور دقیق پیش‌بینی می‌کند که آیا یال داده شده حداقل $\rho$ مثلث دارد یا نه. نحوه ساده‌کردن (relax) این فرض در بخش ۱.۱.۲ آورده شده است.

## مدل لیست مجاورت
***مدل لیست مجاورت (Adjacency List Model)*** تمام رخدادهای یک گره یکسان باهم می‌رسند.

***تئوری ۱.۱*** وجود دارد یک الگوریتم تک‌گذر (الگوریتم ۱) وجود دارد که با پیچیدگی فضایی زیر در یک مدل لیست مجاورت با استفاده از یک اوراکل برپایه یادگیری تعداد مثلث‌ها ($T$) با احتمال حداقل 70٪ را با خطای $1\pm \epsilon$ نسبت به $T$ بدست آورد.
![[Pasted image 20220709135029.png]]

جزئیات الگوریتم ۱ در بخش ۲ مقاله آورده شده است و تحلیل کامل آن در پیوست B آورده شده است.

## مدل ترتیب اختیاری
***مدل ترتیب اختیاری*** در این مدل یال در جریان با هر ترتیب دلخواهی می‌آید. یک الگوریتم تک‌گذر برای شمارش مثلث‌ها و یک الگوریتم دیگر برای شمارش چهارتایی‌ها ارائه شده است که هر دو الگوریتم تعداد گذرها را در مقایسه با بهترین الگوریتم از نظر پیچیدگی حافظه کاهش می‌دهد. نتایج بعدی ما در ادامه آورده شده است.

***تئوری ۱.۲*** یک الگوریتم تک‌گذر (الگوریتم ۴) وجود دارد که با پیچیدگی حافظه زیر در یک مدل با ترتیب اختیاری با استفاده از اوراکل برپایه یادگیری تعداد مثلث‌ها $T$ را با احتمال ۷۰٪ را با خطای $1 \pm \epsilon$ نسبت به $T$ بدست آورد.
![[Pasted image 20220709140256.png]]

الگوریتم ۴ در بخش ۳ توضیح داده شده است و توضیحات کامل‌تر آن در پیوست C مقاله ارائه شده است.

آن‌ها نشان داده‌اند که حدپایین غیربدیهی فضا قابل حصول است اگر پیش‌بینی مناسب در دسترس باشد. در تئوری C.2 در پیوست C.3 مقاله اثبات کردند که حدپایین برای چنین تنظیمی نیازمند فضای زیر است
![[Pasted image 20220709173204.png]]
با کمک یک اوراکل نشان دادند که نتایجشان در برخی از موارد کاملا منطبق است. به علاوه مسئله شمارش مثلث غیربدیهی است حتی اگر اطلاعات اضافه در دسترس باشد.

***شمارش چهارتایی*** برای شمارش  چهارتایی‌ها در یک مدل با ترتیب اختیاری تئوری ۱.۳ که در پیوست D‌ آورده شده است برقرار است.

***تئوری ۱.۳*** الگوریتم تک‌گذری وجود دارد (الگوریتم ۵) با پیچیدگی فضایی زیر دارد که با استفاده از اوراکل برپایه یادگیری تعداد ($T$) مثلث‌ها را با احتمال ۷۰٪ برمی‌گرداند به گونه‌ای تخمین با خطای $1 \pm \epsilon$ باشد.
![[Pasted image 20220709174148.png]]

## پاراگراف‌های آخر
برای خلاصه‌کردن مشارکت تئوریشان برای اولین مجموعه از نتایج شمارش مثلث‌ها در مدل لیست مجاورت، حدود همواره از مدل‌های برتر فعلی برای تمام مقادیر $m$ و $T$ بهبود پیدا کرده است. برای یک مثال واقعی فرض کنید که $T = \Theta (\sqrt m)$. در این حالت حد حافظه پیشین برابر با $\tilde{O}(m^{\frac{3}{4}})$ بوده است درحالی که در روش پیشنهادی این مقدار برابر با $\tilde{O}(\sqrt{m})$ است.

برای دو مسئله دیگر از شمارش مثلث و چهارتایی در مدل ترتیب اختیاری حد حافظه مدل پیشنهادی برابر با مدل‌های پیشین بوده است اما تنها نیازمند یک گذر به جای چندین گذر بوده است. 

در حالتی که گراف ورودی چگالی مثلثی بالایی دارد یعنی $T = O(\frac{m}{\epsilon^2})$. نتایج یکسانی بدست می‌آید با یک بهبود وابسته به $\epsilon$. به علاوه درحالت $T \le \frac{m}{\epsilon^2}$ که برای بسیاری از مجموعه‌داده‌های واقعی طبیعی است، برای $\epsilon = 0.05$ این شرط برای تمام مجموعه‌داده‌های واقعی برقرار است:
![[Pasted image 20220709181857.png]]
بدون درنظر گرفتن چگالی مثلثی یک مزیت کلیدی برای نتایج آن‌ها استفاده از یک گذر به جای چندین گذر است. نهایتا نتایج آن‌ها برای چهار گراف کلی و بدون هیچ فرض اضافی بدست آمده است. بیشتر الگوریتم آن‌ها نسبتا ساده است و به سادگی امکان پیاده‌سازی و راه‌اندازی آن وجود دارد. در عین حال برخی از نتایج آن‌ها نیازمند استفاده از تکنیک‌های خلاقانه در این زمینه مانند استفاده از متغیر تصادفی نمایی دارد. (مطابق فصل ۲)

