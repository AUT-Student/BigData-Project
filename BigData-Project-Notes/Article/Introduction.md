# ابتدای فصل
## پاراگراف اول
شمارش تعداد دورها در یک گراف یک مسئله پایه‌ی در حوزه مدل جریانی گرافی است. شمارش مثلث‌ها به عنوان یک نوع خاص بیشتر مورد بررسی بوده است و کاربردهای زیادی داشته است. به طور خاص این مورد بینش مهمی از ویژگی‌های ساختاری شبکه‌ها می‌دهد که می‌تواند استفاده شود تا شکل عمده شبکه‌های تعامل پروتئین، فهم شبکه‌های اجتماعی و ارزیابی مدل‌های گرافی بزرگ را کشف کند.

## پاراگراف دوم
به دلیل اهمیت آن بدنه مهمی از تحقیقات به الگوریتم‌های جریانی که از نظر فضایی برای شمارش مثلث با خطای $1+\epsilon$ بهینه است تعلق دارد. چنین الگوریتم‌هایی محاسبه را در یک یا چند گام اول روی داده با استفاده پیچیدگی خطی (sub-linear) از نظر زمانی انجام می‌دهد.  یک مشکل مشترک در تمام کارهای قبلی وجود یال‌های سنگین (heavy edge) بوده است. چنین یال‌هایی در مثلث‌های زیادی وجود دارد. الگوریتم‌ها با پیچیدگی خطی از نظر حافظه غالبا برپایه نمونه‌برداری از یال‌ها هستند که در نتیجه انتخاب و ذخیره‌سازی یک یال سنگین که تاثیر شدیدی بر تعداد مثلث‌ها دارد می‌تواند کلید یک پیش‌بینی دقیق باشد. بنابراین چندین تکنیک توسعه داده‌شده است که تشخیص دهد آیا یک یال سنگین است یا خیر.

## پاراگراف سوم
اخیرا برپایه مشاهد‌ه اینکه تعداد زیادی از الگوهای اساسی در مجموعه‌داده‌های واقعی به سرعت در طول زمان تغییر نمی‌کند، تکنیک‌های یادگیری‌ماشین در مدل جریان‌داده با آموزش اوراکل‌های ضربه‌زن سنگین (heavy-hitter) ادغام شده است. دسترسی داشتن به چنین اوراکل برپایه یادگیری ماشین رنج وسیعی از مسائل در پردازش جریان داده را بهبود داده است. حد حافظه از الگوریتم‌های کلاسیک پیشین در تمام این روش‌ها بهتر است.

## پاراگراف چهارم
برپایه پیشرفت‌های اخیر به این پرسش رسیده‌اند که آیا امکان پذیر است که یک اوراکل یال سنگین آموزش‌یافته پیچیدگی فضایی شمارش زیر گراف در یک مدل جریانی گرافی را بهبود دهد. نتایج نشان می‌دهد که پاسخ مثبت است!

# بخش ۱.۱ 
## پاراگراف اول
نتایج عملی و تئوری در چندین مدل جریانی گرافی با چندین نمایش از اواکل‌های پیش‌بینی‌کننده ارائه شده است. از نظر مفهومی بهتر است اول اوراکل‌های کامل (Perfect Oracle) مطالعه شوند که پیش‌بینی دقیقی داشته‌اند. در عمل چنین اوراکلی در دسترس نیست. ارزیابی این اوراکل‌ها از دو طریق صورت گرفته است:
* نشان‌دادن آنکه می‌توانند برای چندین مجموعه‌داده واقعی ساخته شوند.
* نشان‌دادن آنکه در مجموعه‌داده‌های واقعی الگوریتم پشینهادی با استفاده از چنین اوراکل‌هایی بهبود عملی قابل توجهی نسبت به مدل‌های پایه داشته است.

## پاراگراف دوم
$G(V, E)$ گراف ورودی است که $n$، $m$ و $T$ به ترتیب تعداد گره، یال و مثلث‌ها در $G$ باشد. دو نوع مدل جریانی یالی گرافی اصلی وجود دارد: مدل مجاورت لیستی (Adjacency List) و مدل ترتیب اختیاری (Arbitrary Order).
نشان داده‌اند که آموزش اوراکل‌های یال سنگین در عمل با هر دو مدل ممکن است و چنین اوراکلی امکان طراحی الگوریتم‌های جدید که بهبود قابل ملاحظه‌ای بر پیچیدگی فضایی شمارش مثلث‌ها و چهارگوش‌ها بگذارد را ممکن می‌کند؛ چه به صورت تئوری و چه در عمل. به علاوه رسمی‌کردن چهارچوب پیش‌بینی یال سنگین نشان دادن حدپایین قابل اثبات را امکان‌پذیر می‌کند. نتایج در جدول ۱ آورده شده است. (در جدول ۱ $\Delta_E$ و $\Delta_V$ بیشینه تعداد مثلث برای یال و هر گره را نشان می‌دهد و $\kappa$ مقدار arboricity گراف را نشان می‌دهد.)
![[Pasted image 20220709124947.png]]
![[Pasted image 20220716161004.png]]

## پاراگراف سوم
در الگوریتم پیشنهادی فرض شده است که تقریب ثابت بزرگ (large-constant approximation) از $T$ برای هدف تنظیم پارامترهای مختلف شناخته شده است. این یک کار استاندارد در حوزه شمارش جریانی زیرگراف‌ها است. به علاوه زمانی که این فرض مستقیما قابل استنتاج نباشد بخش F.3 مقاله در مورد نحوه تطبیق روش پیشنهادی برای غلبه به این مشکل ارائه شده است.


# اوراکل کامل
## پاراگراف اول
اولین نتایج در حالتی که الگوریتم‌ها دسترسی به اوراکل یال سنگین کامل دارند بدست آمده است. برای حدآستانه $\rho$ یک اوراکل به طور دقیق پیش‌بینی می‌کند که آیا یال داده شده حداقل $\rho$ مثلث دارد یا نه. نحوه ساده‌کردن (relax) این فرض در بخش ۱.۱.۲ آورده شده است.

## مدل لیست مجاورت
***مدل لیست مجاورت (Adjacency List Model)*** تمام رخدادهای یک گره یکسان باهم می‌رسند.

***تئوری ۱.۱*** یک الگوریتم تک‌گذر (الگوریتم ۱) وجود دارد که با پیچیدگی فضایی زیر در یک مدل لیست مجاورت با استفاده از یک اوراکل برپایه یادگیری تعداد مثلث‌ها ($T$) را با احتمال حداقل 70٪ را با خطای $1\pm \epsilon$ بدست آورد.
![[Pasted image 20220709135029.png]]

جزئیات الگوریتم ۱ در بخش ۲ مقاله آورده شده است و تحلیل کامل آن در پیوست B آورده شده است.

## مدل ترتیب اختیاری
***مدل ترتیب اختیاری*** در این مدل یال در جریان با هر ترتیب دلخواهی می‌آید. یک الگوریتم تک‌گذر برای شمارش مثلث‌ها و یک الگوریتم دیگر برای شمارش چهار‌گوش‌ها ارائه شده است که هر دو الگوریتم تعداد گذرها را در مقایسه با بهترین الگوریتم از نظر پیچیدگی حافظه کاهش می‌دهد. نتایج بعدی در ادامه آورده شده است.

***تئوری ۱.۲*** یک الگوریتم تک‌گذر (الگوریتم ۴) وجود دارد که با پیچیدگی حافظه زیر در یک مدل با ترتیب اختیاری با استفاده از اوراکل برپایه یادگیری تعداد مثلث‌ها $T$ را با احتمال ۷۰٪ با خطای $1 \pm \epsilon$ نسبت به $T$ بدست آورد.
![[Pasted image 20220709140256.png]]

الگوریتم ۴ در بخش ۳ توضیح داده شده است و توضیحات کامل‌تر آن در پیوست C مقاله ارائه شده است.

آن‌ها نشان داده‌اند که حدپایین غیربدیهی فضا قابل حصول است اگر پیش‌بینی مناسب در دسترس باشد. در تئوری C.2 در پیوست C.3 مقاله اثبات کردند که حدپایین برای چنین تنظیمی نیازمند فضای زیر است
![[Pasted image 20220709173204.png]]
با کمک یک اوراکل نشان دادند که نتایجشان در برخی از موارد کاملا منطبق است. به علاوه مسئله شمارش مثلث غیربدیهی است حتی اگر اطلاعات اضافه در دسترس باشد.

***شمارش چهارتایی*** برای شمارش  چهارتایی‌ها در یک مدل با ترتیب اختیاری تئوری ۱.۳ که در پیوست D‌ آورده شده است برقرار است.

***تئوری ۱.۳*** الگوریتم تک‌گذری وجود دارد (الگوریتم ۵) با پیچیدگی فضایی زیر دارد که با استفاده از اوراکل برپایه یادگیری تعداد ($T$) مثلث‌ها را با احتمال ۷۰٪ برمی‌گرداند به گونه‌ای تخمین با خطای $1 \pm \epsilon$ باشد.
![[Pasted image 20220709174148.png]]

## پاراگراف‌های آخر
برای خلاصه‌کردن مشارکت تئوریشان برای اولین مجموعه از نتایج شمارش مثلث‌ها در مدل لیست مجاورت، حدود همواره از مدل‌های برتر فعلی برای تمام مقادیر $m$ و $T$ بهبود پیدا کرده است. برای یک مثال واقعی فرض کنید که $T = \Theta (\sqrt m)$. در این حالت حد حافظه پیشین برابر با $\tilde{O}(m^{\frac{3}{4}})$ بوده است درحالی که در روش پیشنهادی این مقدار برابر با $\tilde{O}(\sqrt{m})$ است.

برای دو مسئله دیگر از شمارش مثلث و چهارتایی در مدل ترتیب اختیاری حد حافظه مدل پیشنهادی برابر با مدل‌های پیشین بوده است اما تنها نیازمند یک گذر به جای چندین گذر بوده است. 

در حالتی که گراف ورودی چگالی مثلثی بالایی دارد یعنی $T = O(\frac{m}{\epsilon^2})$. نتایج یکسانی بدست می‌آید با یک بهبود وابسته به $\epsilon$. به علاوه درحالت $T \le \frac{m}{\epsilon^2}$ که برای بسیاری از مجموعه‌داده‌های واقعی طبیعی است، برای $\epsilon = 0.05$ این شرط برای تمام مجموعه‌داده‌های واقعی برقرار است:
![[Pasted image 20220709181857.png]]
بدون درنظر گرفتن چگالی مثلثی یک مزیت کلیدی برای نتایج آن‌ها استفاده از یک گذر به جای چندین گذر است. نهایتا نتایج آن‌ها برای چهار گراف کلی و بدون هیچ فرض اضافی بدست آمده است. بیشتر الگوریتم آن‌ها نسبتا ساده است و به سادگی امکان پیاده‌سازی و راه‌اندازی آن وجود دارد. در عین حال برخی از نتایج آن‌ها نیازمند استفاده از تکنیک‌های خلاقانه در این زمینه مانند استفاده از متغیر تصادفی نمایی دارد. (مطابق فصل ۲)

# اوراکل نویزی
نتایج شمارش مثلث فوق‌الذکر تحت این فرض که الگوریتم‌ها دسترسی به اوراکل یال سنگین کامل دارند بیان شده است. در عمل چنین فرضی بعضی اوقات غیرواقعی است. بنابراین چندین نوع اوراکل نویزی درنظرگرفته شده است. اولین نوع آن اوراکل k-نویزی است.

***تعریف ۱.۱*** برای هر یال $e=xy$ در جریان $N_e$ برابر با تعداد مثلث‌ها که شامل هم $x$ و هم $y$ باشد تعریف می‌شود. برای یک عدد ثابت $K \ge 1$ و یک حد آستانه $\rho$ گفته می‌شود که $O_\rho$ یک اوراکل k-نویزی است اگر برای هر یال $e$ داشته باشیم:
![[Pasted image 20220709184923.png]]

این اوراکل با احتمال بالا دسته‌بندی می‌کند که کدام یال شدیدا سنگین یا شدیدا سبک است اما اگر یک یال نزدیک به آستانه باشد، اوراکل ممکن است که دقیق نباشد. در مورد ویژگی چنین اوراکلی در پیوست G اطلاعات بیشتری آورده شده است.

***تئوری ۱.۴*** فرض کنید که اوراکل داده‌شده به الگوریتم ۱ از نوع k-نویزی مطابق با تعریف ۱.۱ باشد. در این حالت با احتمال ۲/۳ الگوریتم ۱ مقدار $(1 \pm \sqrt{k}.\epsilon)T$ را بر می‌گرداند و حداکثر به حافظه زیر نیاز دارد
![[Pasted image 20220709190752.png]]

بنابراین حتی اگر اوراکل برای یال‌های نزدیک آستانه دقیق نباشد الگوریتم پیشنهادی همچنان تخمین مناسبی با حافظه کم در مدل لیست مجاورت دارد. به طور مشابه برای مدل ترتیب تصادفی مطابق با تئوری C.1‌ اثبات کرده‌اند که الگوریتم تک‌گذر تئوری ۱.۲ با حافظه زیر و با داشتن اوراکل k-نویزی می‌تواند با الگوریتم ۴ کار کند.
![[Pasted image 20220709191327.png]]

اثبات تئوری ۱.۴ در پیوست B.1‌ آورده شده است و اثبات تئوری C.1 در پیوست C.2 آورده شده است. این دو تئوری، تئوری ۱.۱ و ۱.۲ را برای اوراکل k-نویزی برآورده می‌کنند.

***اوراکل مقداری (نویزی)*** در مدل لیست مجاورت زمانی که یک یال $xy$ دیده می‌شد دسترسی به تمام همسایه‌های $x$ یا $y$ وجود داشت که امکان آنکه اوراکل بتواند پیش‌بینی دقیق داشته باشد وجود داشت. برای یک یال $xy$ مقدار $R_{xy}$ تعداد مثلث‌های $xyz$ است به گونه‌ای که $x$ مقدم بر $z$ و $z$ مقدم بر $y$ در ترتیب جریان داده باشد. 

با انگیزه‌های نتایج عملی مطابق فصل F.7 این منطقی است که در برخی از تنظیمات فرض شود که دسترسی به اوراکل با تخمین خوب $R_{xy}$ در دسترس باشد. چنین اوراکلی اوراکل مقداری نامیده می‌شود.

***تعریف ۱.۲*** با داشتن یک یال $e$ یک اوراکل پیش‌بینی مقدار $(\alpha, \beta)$ یک مقدار تصادفی $p(e)$ را خروجی می‌دهد که روابط زیر برای یک ثابت $k$ و $\lambda \ge 1$ برقرار است.
![[Pasted image 20220709192655.png]]

***تئوری ۱.۵*** با داشتن یک اوراکل با پارامتر های $(\alpha, \beta)$ یک الگوریتم تک‌گذر (الگوریتم ۲) با پیچیدگی فضایی زیر در مدل لیست مجاورت وجود دارد که تخمین $1 \pm \epsilon$ از تعداد مثلث‌ها $T$ با احتمال حداقل ۷۰٪ بر می‌گرداند.
![[Pasted image 20220709192959.png]]

در نسخه دوم از اوراکل نویزی فرض شده است که خطای تقریب به صورت خطی با خطای بالا و پایین کاهش می‌یابد. برای این نسخه نیز مطابق تئوری B.1‌ اثبات می‌شود که تضمین مشابه تئوری ۱.۵ وجود دارد. الگوریتم و اثبات‌ها برای تئوری ۱.۵ و تئوری B.1‌در پیوست B.2‌ آورده شده است.

# آزمایشات
آزمایشاتی برای تایید نتایج شمارش مثلث‌ها بر روی رنجی از شبکه‌های واقعی انجام شده است؛ هم برای مدل ترتیب اختیاری و هم مدل لیست مجاورت. الگوریتم پیشنهادی از اطلاعات اضافی پیش‌بینی‌کننده‌ها استفاده می‌کند تا نتایج عملی را بهبود دهد. پیش‌بینی‌کننده‌ها وابسته به داده هستند و شامل موارد زیر هستند:
* حفظ کردن یال‌های سنگین در بخش کوچکی از اولین گراف در دنباله‌ای از گراف‌ها
* رگرسیون خطی
* شبکه عصبی گرافی (GNN)

نتایج نشان می‌دهد که تا پنج برابر کاهش خطای تخمین با نگهداری تعداد برابر یال نسبت به مدل‌های برتر فعلی وجود دارد. برای نتایج بیشتر بخش ۴ را مشاهده کنید. 
در بخش F.7 نشان داده شده است که اوراکل نویزی برای مجموعه‌داده‌های واقعی قابل دسترس هستند.

# کارهای عملی مرتبط
از نظر عملی تمرکز بیشتر برای شمارش مثلث‌ها در مدل ترتیب اختیاری بوده است. دو مدل پایه ThinkD و WRS به عنوان مدل پایه انتخاب شده است. در این کارها نویسندگان مقایسه‌ای با بنچمارک‌های عملی پیشین انجام داده‌اند و برتری خود را نشان داده‌اند. باتوجه به کارایی عملی قوی و در دسترس بودن کد این دو مدل در نظر گرفته شده است.

# پیش‌بینی‌کننده‌های ضمنی در کارهای پیشین
ایده استفاده از پیش‌بینی‌کننده به صورتی ضمنی در کارهای پیشین بوده است. الگوریتم بهینه شمارش مثلث با دو گذر را می‌توان به چشم یک پیاده‌سازی از اوراکل یال سنگین بعد از گذر اول دید. این اوراکل حتی از اوراکل k-نویزی قوی‌تر است و برابر با اوراکلی است که همواره برای یک یال $e$ پیش‌بینی درست می‌کند اگر $N_e$ از حدآستانه $\rho$ رد کند یا کمتر باشد با یک نسبت ضرب ثابت. این مورد انتخاب اوراکل پیشنهادی در نتایج تئوری در جلوتر را حمایت می‌کند، با توجه به اینکه یک نسخه قوی‌تر از اوراکل پیشنهادی می‌تواند با یک گذر اضافه روی جریان داده توسعه بیابد (پیوست G).

به طور مشابه الگوریتم بهینه جریانی شمارش مثلث ( با فرض ترتیب تصادفی) می‌تواند به صورت ضمنی یک اوراکل یال سنگین را با استفاده از نسبت کوچک اولیه‌ای از جریان تصادفی تعریف کند. فرض ترتیب تصادفی ایجاد چنین اوراکلی را امکان‌پذیر می‌کند از آنجایی که یال‌های سنگین با احتمال بالا تعداد زیادی از رخدادهای بخش اولیه جریان را تشکیل می‌دهند. 

از این دو کار برای تنظیم تئوری تعریف اوراکل پیشنهادی استفاده شده است.

الگوریتم WRS ویژگی تعریف یک اوراکل ضمنی را به این شکل به معرفی کرده است: برخی از فضا برای نگهداری یال‌های اخیر رزرو می‌شود درحالی که مابقی آن برای نگهداری یال‌های تصادفی استفاده می‌شود. این حالت می‌تواند یک حالت خاص از مدل پیشنهادی باشد که اوراکل یال‌های اخیر را به عنوان سنگین پیش‌بینی می‌کند.

# مباحث مقدماتی
$G(V, E)$ گراف ورودی است. $n$، $m$ و $T$ به ترتیب تعداد رئوس، یال‌ها و مثلث‌ها ( یا چهارتایی‌ها) را به ترتیب در گراف نشان می‌دهد. $N(v)$ همسایه‌های گره $v$ را نشان می‌دهد و $\Delta$ مجموعه مثلث‌ها را نشان می‌دهد. در شمارش مثلث برای هر یال $xy \in E(G)$ عداد مثلث‌های شامل این یال با نماد $N_{xy}$ نشان داده می‌شود. نهایتا مثلث‌هایی که شامل این یال و گره $z$ به عنوان گره سوم که بین $x$ و $y$ در ترتیب لیست مجاورت آمده باشد با نماد $R_{xy}$ نشان داده می‌شود. روابط این دو در ادامه آورده شده است:
![[Pasted image 20220709205008.png]]
![[Pasted image 20220709205022.png]]

لیست کامل نمادها عبارت است از:
![[Pasted image 20220709205042.png]]
