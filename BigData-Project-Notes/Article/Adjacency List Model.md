# اوراکل یال سنگین
الگوریتم تک‌گذر ۱ با پیچیدگی حافظه زیر طبق تئوری ۱.۱ ارائه شده است.
![[Pasted image 20220709225851.png]]
سودوکد و اثبات آن در پیوست B‌ مقاله است.
![[Pasted image 20220710093854.png]]

بسته به مقدار $T$ الگوریتم پیشنهادی متفاوت است. 

## حالت اول
در این حالت $T \ge {(\frac{m}{\epsilon})}^{\frac{1}{2}}$ است.
فرض می‌شود که برای هر یال نمونه‌برداری‌شده $xy$ در جریان می‌توان $R_{xy}$ را استخراج کرد. نرخی که هر یال باید با آن نمونه‌برداری شود برابر است با $p_{naive} \approx \frac{\epsilon^{-2}\Delta_E}{T}$. در این رابطه $\Delta_E$ حداکثر تعداد درخت شامل هر یال است. بنابراین ایده اول آن‌ها جداکردن یال‌های سبک و غیرسبک با کمک یک اوراکل یال سنگین بوده است. چنین کاری امکان نمونه‌برداری یالی که توسط اوراکل با احتمال پایین $p_1$ سبک درنظر گرفته شده است را فراهم می‌کند و مشارکت آن‌ها را با ردیابی $R_{xy}$ برای هر یال نمونه‌برداری‌شده حساب می‌کند. به طور شهودی یال‌های سبک انعطاف بیشتری به ما می‌دهند و بنابراین می‌توانیم آن‌ها را با احتمال کمتری انتخاب کنیم بدون آنکه خطا به طرز جدی‌ای افزایش پیدا کند. به منظور تخمین مشارکت یال‌های غیرسبک آن‌ها بر اساس آستانه $\rho$ به دو نوع سنگین و معمولی شکسته می‌شوند. برای یال‌های سنگین $\rho < R_{xy}$ کافی است که آن‌ها را در کل جریان با نرخ $p_3 \approx \frac{\epsilon^{-2}}{\rho}$ انتخاب شوند تا هم اگر یال $xy$ سنگین باشد شناسایی شود و هم بتوان تخمینی از $R_{xy}$ داشت.

بنابراین تخمین میزان مشارکت باتوجه به یال‌های متوسط تعیین می‌شود. از آنجایی که تعداد رخداد مثلث با یال‌های متوسط بیشتر از یال‌های سبک است با نرخ بیشتری نمونه‌برداری می‌شوند: $p_2 > p_1$. اگرچه تعدادشان محدود است ولی از نظر فضایی بهینه است. با تنظیم صحیح آستانه بین یال‌های سبک، متوسط و سنگین به حدود مناسب می‌توان دست یافت.

## حالت دوم
در این حالت  $T > {(\frac{m}{\epsilon})}^{\frac{1}{2}}$ است.
الگوریتم ساده‌تر می‌شود. در این حالت دو نوع یال با توجه به حد آستانه $T/\rho$ وجود دارد: سبک و سنگین. برای تخمین مشارکت یال‌های سنگین به طور ساده آن‌ها را نگه می‌دارند و مقدار $R_{xy}$ را برای آن ردیابی می‌کنند. برای تخمین مشارکت یال‌های سبک با نرخ $\epsilon^{-2}.\Delta_E/T = \epsilon^{-2}/\rho$ آن‌ها را نمونه‌برداری می‌کنند. فضای کل استفاده شده برابر با $\tilde{O}(\epsilon^{-1}\sqrt{m})$ که مقداری بهینه است. الگوریتم ۱ شامل جزئیات پیاده‌سازی آن است.

# اوراکل مقداری
حالتی که پیش‌بینی‌کننده یک تخمین $p(e)$ از $R_e$ برمی‌گرداند نیز درنظر گرفته شده است و فرض می‌شود که $R_e \le p(e) \le \alpha$ که در این رابطه  $\alpha \ge 1$ یک فاکتور تخمین است. این فرض برای مدیریت کردن خطای افزایشی و نویز ساده می‌شود اما برای درک بهتر بیشتر بررسی می‌شود. تنظیم اوراکل مقداری نیازمند استفاده از تکنیک‌های خلاقانه نظیر متغیر تصادفی نمایی است. با داشتن این اوراکل برای یک یال $e$ مقدار $p(e)/u_e$ حساب می‌شود که $u_e$ متغیر تصادفی نمایی است. سپس $O(\alpha log(1/ \epsilon))$ یال که مقدار $p(e)/u_e$ برای آن بیشینه است نگهداری می‌شود. از آنجایی که مدل از نوع لیست مجاورت است زمانی که یال $e = xy$ ردیابی می‌شود می‌توان مقدار واقعی $R_e$ را محاسبه کرد. چرا که برای هر $z$ می‌توان بررسی کرد که آیا همسایه هر دوی $x$ و $y$ است یا نه. توجه شود که این مقادیر تنها برای $O(\alpha log(1/ \epsilon))$ یال ردیابی می‌شود. با استفاده از ویژگی بیشینه پایداری متغیرهای تصادفی نمایی $max_e\, R_e/u_e$ در توزیع برابر با $T/u$ است که $u$ یک متغیر تصادفی نمایی دیگر است.  به طور مهم با استفاده از تابع چگالی یک متغیر تصادفی نمایی می‌توان نشان داد که یال $e$ ای که بیشترین $R_e/u_e$ را دارد با احتمال $1-O(\epsilon^3)$ در لیست یال‌های منتخب بیشترین مقدار $p(e) / u_e$ را دارد. با تکرار این برنامه به تعداد $r = O(1/\epsilon^2)$ مرتبه تخمین‌های مستقل $T/u^1$ تا $T/u^r$ بدست می‌آید که $u^1$ تا $u^r$ متغیر تصادفی نمایی هستند. با میانه گرفتن از این‌ها یک تخمین با خطای $(1 \pm \epsilon)$ از تعداد کل مثلث‌ها ($T$) بدست می‌آید.

متغیرهای تصادفی نمایی غالبا در کاربردهای جریان داده استفاده می‌شود و پیش‌تر در حوزه تخمین تعداد مثلث استفاده نشده است. همچنین یک الگوریتم جایگزین دیگر ارائه شده است که با نمونه‌برداری با مقیاس $O(log(n))$ دارای بدترین فاکتورهای لگاریتمی در تئوری است ولی در عمل نتایج خوبی داشته است.

![[Pasted image 20220710202053.png]]
![[Pasted image 20220710202145.png]]
